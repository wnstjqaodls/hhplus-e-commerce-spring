## 프로젝트
이커머스 상품을 조회하고, 상품을 결제하는 애플리케이션입니다.

## 아키텍처
로버트C 마틴의 Clean Architecture를 기반으로 합니다.

## 아키텍터 선정 이유
1. 유지보수성 : 코드의 변경부분을 최소화 하기 위해 아키텍처를 분리합니다.
2. 테스트 용이성 : 클린 아키텍처를 적용하여 시나리오를 나누면 테스트 코드를 작성하기 편리합니다.
3. 이식성 : 특정 도메인을 다른 MSA 로 변환하거나, 패키지 자체를 잘라내서 다른 코드베이스에서 사용하면 그 자체로 도메인 애플리캐이션이 될 수 있습니다.
4. 유지보수성2 : 특정 도메인 로직을 확인하려할때 레이어드 아키텍처는 특정 도메인이 레이어에 걸쳐있지만 해당 아키텍처는 특정 도메인 아래에서부터 찾기 시작하고, 코어 비즈니스 로직만 domain 패키지 아래에서 확인하고 싶을때 편리합니다.
5. 유연성 : 외부 인프라와 완전 독립되어있기에 , 외부 인프라가 변경되어도 도메인 로직은 변경되지 않습니다.<br> 예를들면 상품결제 인프라만 DB를 postgresql로 변경하고, 상품조회 인프라는 mysql로 변경해도 도메인 로직은 변경되지 않습니다. 

## 단점과 트레이드 오프
1. 복잡성 : 레이어드 아키텍처에 비해 복잡도가 증가합니다. 도메인 로직을 찾기 위해서는 도메인 패키지 아래에서부터 찾아야 합니다.<br>
   예를 들어, 상품 도메인 로직을 찾으려면 `domain/product` 패키지 아래에서부터 찾아야 합니다. 이는 레이어드 아키텍처에서는 `service/product` 패키지 아래에서 찾는 것보다 복잡할 수 있습니다.<br> 또한 단순 CRUD 또는 조회성 로직을 개발하려할때에도 지나치게 인터페이스와 포트,어댑터 등의 파일갯수 자체가 많아집니다.
2. 학습 곡선 : 클린 아키텍처를 처음 접하는 개발자에게는 학습 곡선이 있을 수 있습니다. 도메인 주도 설계(DDD)와 함께 사용될 때 더욱 복잡해질 수 있습니다.
3. 예외 패키지 : 클린아키텍처에 해당하지않는 config 또는 기타 패키지가 존재합니다. 이는 클린 아키텍처의 원칙에 위배되지만, 실제로는 필요한 경우가 많습니다. 예를 들어, config 패키지는 애플리케이션 설정을 관리하기 위해 필요합니다.


